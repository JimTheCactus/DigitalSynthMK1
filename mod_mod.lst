   1               		.file	"mod_mod.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.startup,"ax",@progbits
  11               	.global	main
  13               	main:
  14               	.LFB2:
  15               		.file 1 "mod_mod.c"
   1:mod_mod.c     **** #include <avr/io.h>
   2:mod_mod.c     **** #include <math.h>
   3:mod_mod.c     **** #include <avr/sleep.h>
   4:mod_mod.c     **** #include <avr/interrupt.h>
   5:mod_mod.c     **** 
   6:mod_mod.c     **** #define PRESCALER 2 // 2 selects the /8 prescaler
   7:mod_mod.c     **** #define PRESCALER_RATIO 8
   8:mod_mod.c     **** #define TICK_PERIOD (1.0/(float)(F_CPU)*(float)(PRESCALER_RATIO))
   9:mod_mod.c     **** #define A440 2273 // Ticks assuming 8MHz clock and /8 prescaler
  10:mod_mod.c     **** #define A440_BY_2 (A440>>1) // Half so we can toggle
  11:mod_mod.c     **** #define SEMITONES_PER_OCTAVE 12 // From music theory
  12:mod_mod.c     **** #define SCALE_BOTTOM (24+12) // Note number on a scale where A440 is 57
  13:mod_mod.c     **** #define SCALE_TOP (SCALE_BOTTOM+SEMITONES_PER_OCTAVE*2) // 2 octaves
  14:mod_mod.c     **** #define SCALE_RANGE (float)(SCALE_TOP-SCALE_BOTTOM)/(float)(1024)
  15:mod_mod.c     **** #define REF_FREQENCY (float)440.0 // Call A440 our reference frequency
  16:mod_mod.c     **** #define REF_NOTE 57 // Call 57 the reference note number for A440.
  17:mod_mod.c     **** #define OSC_OFF (unsigned char) ~(3<< CS10); // All 0s for the CS regs.
  18:mod_mod.c     **** 
  19:mod_mod.c     **** 
  20:mod_mod.c     **** int main(void) {
  16               		.loc 1 20 0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  21:mod_mod.c     **** 	// Set OCA1 (Pin B1 on the PDIP package) to be an output.
  22:mod_mod.c     **** 	DDRB=1<<DDB1;
  22               		.loc 1 22 0
  23 0000 82E0      		ldi r24,lo8(2)
  24 0002 84B9      		out 0x4,r24
  23:mod_mod.c     **** 
  24:mod_mod.c     **** 	// Turn of all the stuff we're not using.
  25:mod_mod.c     **** 	PRR =
  25               		.loc 1 25 0
  26 0004 86EE      		ldi r24,lo8(-26)
  27 0006 8093 6400 		sts 100,r24
  26:mod_mod.c     **** 		1 << PRTWI | // Shutdown the I2C Interface
  27:mod_mod.c     **** 		1 << PRTIM2 | // Shutdown Timer2
  28:mod_mod.c     **** 		1 << PRTIM0 | // Shutdown Timer0
  29:mod_mod.c     **** 		0 << PRTIM1 | // Leave Timer1 on
  30:mod_mod.c     **** 		1 << PRSPI | // Shutdown the SPI interface
  31:mod_mod.c     **** 		1 << PRUSART0 | // Shutdown the UART interface
  32:mod_mod.c     **** 		0 << PRADC; // Leave the ADC on
  33:mod_mod.c     **** 		
  34:mod_mod.c     **** 	// Initialize the PWM
  35:mod_mod.c     **** 	OCR1A = A440_BY_2; // Set the initial toggle period to half the A440 period
  28               		.loc 1 35 0
  29 000a 80E7      		ldi r24,lo8(112)
  30 000c 94E0      		ldi r25,lo8(4)
  31 000e 9093 8900 		sts 136+1,r25
  32 0012 8093 8800 		sts 136,r24
  36:mod_mod.c     **** 	                   // (Half because it will toggle after this period)
  37:mod_mod.c     **** 	TCCR1A = 
  33               		.loc 1 37 0
  34 0016 83E4      		ldi r24,lo8(67)
  35 0018 8093 8000 		sts 128,r24
  38:mod_mod.c     **** 		3 << WGM10 | // Set Fast PWM (lower 2 bits)
  39:mod_mod.c     **** 		1 << COM1A0; // Enable toggle mode
  40:mod_mod.c     **** 	TCCR1B =
  36               		.loc 1 40 0
  37 001c 8AE1      		ldi r24,lo8(26)
  38 001e 8093 8100 		sts 129,r24
  41:mod_mod.c     **** 		3 << WGM12 |       // Set Fast PWN (upper 2 bits)
  42:mod_mod.c     **** 		PRESCALER << CS10; // Enable /8 prescaler, Fast PWM
  43:mod_mod.c     **** 	
  44:mod_mod.c     **** 	// Initialize the ADC
  45:mod_mod.c     **** 	ADMUX =
  39               		.loc 1 45 0
  40 0022 80E4      		ldi r24,lo8(64)
  41 0024 8093 7C00 		sts 124,r24
  46:mod_mod.c     **** 		1 << REFS0 | // Use AVCC for reference
  47:mod_mod.c     **** 		0 << ADLAR | // Right align result
  48:mod_mod.c     **** 		0 << MUX0;   // Select pin 0
  49:mod_mod.c     **** 	ADCSRA =
  42               		.loc 1 49 0
  43 0028 8EEA      		ldi r24,lo8(-82)
  44 002a 8093 7A00 		sts 122,r24
  50:mod_mod.c     **** 		1 << ADEN |  // Enable ADC
  51:mod_mod.c     **** 		1 << ADATE | // Enable auto trigger
  52:mod_mod.c     **** 		1 << ADIE |  // Enable interrupt
  53:mod_mod.c     **** 		6 << ADPS0;  // use /64 prescaler
  54:mod_mod.c     **** 	ADCSRB = 0 << ADTS0; // Select free running auto trigger.
  45               		.loc 1 54 0
  46 002e 1092 7B00 		sts 123,__zero_reg__
  55:mod_mod.c     **** 	DIDR0 = 1 << ADC0D; // Disable digital IO buffer on ADC0
  47               		.loc 1 55 0
  48 0032 81E0      		ldi r24,lo8(1)
  49 0034 8093 7E00 		sts 126,r24
  56:mod_mod.c     **** 
  57:mod_mod.c     **** 	// Set IDLE sleep mode. Not much power savings,
  58:mod_mod.c     **** 	// but we need Timer1 to be alive.
  59:mod_mod.c     **** 	set_sleep_mode(SLEEP_MODE_IDLE);
  50               		.loc 1 59 0
  51 0038 83B7      		in r24,0x33
  52 003a 817F      		andi r24,lo8(-15)
  53 003c 83BF      		out 0x33,r24
  60:mod_mod.c     **** 	
  61:mod_mod.c     **** 	// Start the ADC
  62:mod_mod.c     **** 	ADCSRA |= (1 << ADSC);
  54               		.loc 1 62 0
  55 003e 8091 7A00 		lds r24,122
  56 0042 8064      		ori r24,lo8(64)
  57 0044 8093 7A00 		sts 122,r24
  63:mod_mod.c     **** 	
  64:mod_mod.c     **** 	// Enable interrupts so we can wake up after conversions.
  65:mod_mod.c     **** 	sei();	
  58               		.loc 1 65 0
  59               	/* #APP */
  60               	 ;  65 "mod_mod.c" 1
  61 0048 7894      		sei
  62               	 ;  0 "" 2
  63               	/* #NOAPP */
  64               	.L4:
  66:mod_mod.c     **** 	
  67:mod_mod.c     **** 	while (1) {
  68:mod_mod.c     **** 		// Check if the button is pressed
  69:mod_mod.c     **** 		if (PINB & 0x01) { // If not (inverse logic)
  65               		.loc 1 69 0
  66 004a 189B      		sbis 0x3,0
  67 004c 00C0      		rjmp .L2
  70:mod_mod.c     **** 			TCCR1B &= OSC_OFF; // Kill the oscillator
  68               		.loc 1 70 0
  69 004e 8091 8100 		lds r24,129
  70 0052 8C7F      		andi r24,lo8(-4)
  71 0054 00C0      		rjmp .L5
  72               	.L2:
  71:mod_mod.c     **** 		}
  72:mod_mod.c     **** 		else { // Otherwise
  73:mod_mod.c     **** 			TCCR1B |= PRESCALER; // Turn the oscillator on.
  73               		.loc 1 73 0
  74 0056 8091 8100 		lds r24,129
  75 005a 8260      		ori r24,lo8(2)
  76               	.L5:
  77 005c 8093 8100 		sts 129,r24
  74:mod_mod.c     **** 		}
  75:mod_mod.c     **** 		// Take a nap to save power till the next conversion finishes.
  76:mod_mod.c     **** 		sleep_mode();
  78               		.loc 1 76 0
  79 0060 83B7      		in r24,0x33
  80 0062 8160      		ori r24,lo8(1)
  81 0064 83BF      		out 0x33,r24
  82               	/* #APP */
  83               	 ;  76 "mod_mod.c" 1
  84 0066 8895      		sleep
  85               		
  86               	 ;  0 "" 2
  87               	/* #NOAPP */
  88 0068 83B7      		in r24,0x33
  89 006a 8E7F      		andi r24,lo8(-2)
  90 006c 83BF      		out 0x33,r24
  77:mod_mod.c     **** 	}
  91               		.loc 1 77 0
  92 006e 00C0      		rjmp .L4
  93               		.cfi_endproc
  94               	.LFE2:
  96               	.global	__floatunsisf
  97               	.global	__mulsf3
  98               	.global	__addsf3
  99               	.global	__divsf3
 100               	.global	__subsf3
 101               	.global	__fixunssfsi
 102               		.text
 103               	.global	__vector_21
 105               	__vector_21:
 106               	.LFB3:
  78:mod_mod.c     **** }
  79:mod_mod.c     **** 
  80:mod_mod.c     **** ISR(ADC_vect) {
 107               		.loc 1 80 0
 108               		.cfi_startproc
 109 0000 1F92      		push r1
 110               	.LCFI0:
 111               		.cfi_def_cfa_offset 3
 112               		.cfi_offset 1, -2
 113 0002 0F92      		push r0
 114               	.LCFI1:
 115               		.cfi_def_cfa_offset 4
 116               		.cfi_offset 0, -3
 117 0004 0FB6      		in r0,__SREG__
 118 0006 0F92      		push r0
 119 0008 1124      		clr __zero_reg__
 120 000a 2F93      		push r18
 121               	.LCFI2:
 122               		.cfi_def_cfa_offset 5
 123               		.cfi_offset 18, -4
 124 000c 3F93      		push r19
 125               	.LCFI3:
 126               		.cfi_def_cfa_offset 6
 127               		.cfi_offset 19, -5
 128 000e 4F93      		push r20
 129               	.LCFI4:
 130               		.cfi_def_cfa_offset 7
 131               		.cfi_offset 20, -6
 132 0010 5F93      		push r21
 133               	.LCFI5:
 134               		.cfi_def_cfa_offset 8
 135               		.cfi_offset 21, -7
 136 0012 6F93      		push r22
 137               	.LCFI6:
 138               		.cfi_def_cfa_offset 9
 139               		.cfi_offset 22, -8
 140 0014 7F93      		push r23
 141               	.LCFI7:
 142               		.cfi_def_cfa_offset 10
 143               		.cfi_offset 23, -9
 144 0016 8F93      		push r24
 145               	.LCFI8:
 146               		.cfi_def_cfa_offset 11
 147               		.cfi_offset 24, -10
 148 0018 9F93      		push r25
 149               	.LCFI9:
 150               		.cfi_def_cfa_offset 12
 151               		.cfi_offset 25, -11
 152 001a AF93      		push r26
 153               	.LCFI10:
 154               		.cfi_def_cfa_offset 13
 155               		.cfi_offset 26, -12
 156 001c BF93      		push r27
 157               	.LCFI11:
 158               		.cfi_def_cfa_offset 14
 159               		.cfi_offset 27, -13
 160 001e EF93      		push r30
 161               	.LCFI12:
 162               		.cfi_def_cfa_offset 15
 163               		.cfi_offset 30, -14
 164 0020 FF93      		push r31
 165               	.LCFI13:
 166               		.cfi_def_cfa_offset 16
 167               		.cfi_offset 31, -15
 168               	/* prologue: Signal */
 169               	/* frame size = 0 */
 170               	/* stack size = 15 */
 171               	.L__stack_usage = 15
  81:mod_mod.c     **** 	// Initialize to the reference note.
  82:mod_mod.c     **** 	static float oldnote = REF_NOTE; 
  83:mod_mod.c     **** 		
  84:mod_mod.c     **** 	float input = (float) ADC;  // Get the input value
 172               		.loc 1 84 0
 173 0022 6091 7800 		lds r22,120
 174 0026 7091 7900 		lds r23,120+1
 175               	.LVL0:
 176 002a 80E0      		ldi r24,0
 177 002c 90E0      		ldi r25,0
 178 002e 0E94 0000 		call __floatunsisf
 179               	.LVL1:
  85:mod_mod.c     **** 	// Calculate the new note number
  86:mod_mod.c     **** 	float note = (input * SCALE_RANGE + (float)SCALE_BOTTOM);
 180               		.loc 1 86 0
 181 0032 20E0      		ldi r18,0
 182 0034 30E0      		ldi r19,0
 183 0036 40EC      		ldi r20,lo8(-64)
 184 0038 51E4      		ldi r21,lo8(65)
 185 003a 0E94 0000 		call __mulsf3
 186               	.LVL2:
 187 003e 20E0      		ldi r18,0
 188 0040 30E0      		ldi r19,0
 189 0042 40E8      		ldi r20,lo8(-128)
 190 0044 5AE3      		ldi r21,lo8(58)
 191 0046 0E94 0000 		call __mulsf3
 192               	.LVL3:
 193 004a 20E0      		ldi r18,0
 194 004c 30E0      		ldi r19,0
 195 004e 40E1      		ldi r20,lo8(16)
 196 0050 52E4      		ldi r21,lo8(66)
 197 0052 0E94 0000 		call __addsf3
 198               	.LVL4:
  87:mod_mod.c     **** 	// Average the new note with the old one with 1/3rd feedback
  88:mod_mod.c     **** 	float note_with_feedback = round((note * 2.0 + oldnote) / 3.0);
 199               		.loc 1 88 0
 200 0056 9B01      		movw r18,r22
 201 0058 AC01      		movw r20,r24
 202 005a 0E94 0000 		call __addsf3
 203               	.LVL5:
 204 005e 2091 0000 		lds r18,oldnote.1588
 205 0062 3091 0000 		lds r19,oldnote.1588+1
 206 0066 4091 0000 		lds r20,oldnote.1588+2
 207 006a 5091 0000 		lds r21,oldnote.1588+3
 208 006e 0E94 0000 		call __addsf3
 209               	.LVL6:
 210 0072 20E0      		ldi r18,0
 211 0074 30E0      		ldi r19,0
 212 0076 40E4      		ldi r20,lo8(64)
 213 0078 50E4      		ldi r21,lo8(64)
 214 007a 0E94 0000 		call __divsf3
 215               	.LVL7:
 216 007e 0E94 0000 		call round
 217               	.LVL8:
  89:mod_mod.c     **** 	// Cache the old note for hysteresis. 
  90:mod_mod.c     **** 	oldnote = note_with_feedback;
 218               		.loc 1 90 0
 219 0082 6093 0000 		sts oldnote.1588,r22
 220 0086 7093 0000 		sts oldnote.1588+1,r23
 221 008a 8093 0000 		sts oldnote.1588+2,r24
 222 008e 9093 0000 		sts oldnote.1588+3,r25
 223               	.LVL9:
  91:mod_mod.c     **** 	// Get the delta relative to our reference note offset by half for tuning.
  92:mod_mod.c     **** 	float note_offset = note_with_feedback - ((float)REF_NOTE - 0.5);
 224               		.loc 1 92 0
 225 0092 20E0      		ldi r18,0
 226 0094 30E0      		ldi r19,0
 227 0096 42E6      		ldi r20,lo8(98)
 228 0098 52E4      		ldi r21,lo8(66)
 229 009a 0E94 0000 		call __subsf3
 230               	.LVL10:
  93:mod_mod.c     **** 	// Calculate the exact fractional octave for our note
  94:mod_mod.c     **** 	float octave = note_offset / (float) SEMITONES_PER_OCTAVE;
 231               		.loc 1 94 0
 232 009e 20E0      		ldi r18,0
 233 00a0 30E0      		ldi r19,0
 234 00a2 40E4      		ldi r20,lo8(64)
 235 00a4 51E4      		ldi r21,lo8(65)
 236 00a6 0E94 0000 		call __divsf3
 237               	.LVL11:
 238 00aa 9B01      		movw r18,r22
 239 00ac AC01      		movw r20,r24
  95:mod_mod.c     **** 	// Calculate the frequency of the note given it's octave value
  96:mod_mod.c     **** 	float freq = REF_FREQENCY * pow(2, octave);
 240               		.loc 1 96 0
 241 00ae 60E0      		ldi r22,0
 242 00b0 70E0      		ldi r23,0
 243 00b2 80E0      		ldi r24,0
 244 00b4 90E4      		ldi r25,lo8(64)
 245 00b6 0E94 0000 		call pow
 246               	.LVL12:
 247 00ba 20E0      		ldi r18,0
 248 00bc 30E0      		ldi r19,0
 249 00be 4CED      		ldi r20,lo8(-36)
 250 00c0 53E4      		ldi r21,lo8(67)
 251 00c2 0E94 0000 		call __mulsf3
 252               	.LVL13:
 253 00c6 9B01      		movw r18,r22
 254 00c8 AC01      		movw r20,r24
  97:mod_mod.c     **** 	// Get the note's period and cut it in half since we're toggling.
  98:mod_mod.c     **** 	float period = (1.0 / freq) / 2.0;
 255               		.loc 1 98 0
 256 00ca 60E0      		ldi r22,0
 257 00cc 70E0      		ldi r23,0
 258 00ce 80E8      		ldi r24,lo8(-128)
 259 00d0 9FE3      		ldi r25,lo8(63)
 260 00d2 0E94 0000 		call __divsf3
 261               	.LVL14:
 262 00d6 20E0      		ldi r18,0
 263 00d8 30E0      		ldi r19,0
 264 00da 40E0      		ldi r20,0
 265 00dc 5FE3      		ldi r21,lo8(63)
 266 00de 0E94 0000 		call __mulsf3
 267               	.LVL15:
  99:mod_mod.c     **** 	// Get the number of ticks it's we need to wait between toggles
 100:mod_mod.c     **** 	unsigned int counts = (period / TICK_PERIOD);
 268               		.loc 1 100 0
 269 00e2 2DEB      		ldi r18,lo8(-67)
 270 00e4 37E3      		ldi r19,lo8(55)
 271 00e6 46E8      		ldi r20,lo8(-122)
 272 00e8 55E3      		ldi r21,lo8(53)
 273 00ea 0E94 0000 		call __divsf3
 274               	.LVL16:
 275 00ee 0E94 0000 		call __fixunssfsi
 276               	.LVL17:
 101:mod_mod.c     **** 	// Write the calculated 16 bit number into the register.	
 102:mod_mod.c     **** 	OCR1A = counts; 
 277               		.loc 1 102 0
 278 00f2 7093 8900 		sts 136+1,r23
 279 00f6 6093 8800 		sts 136,r22
 280               	/* epilogue start */
 103:mod_mod.c     **** }
 281               		.loc 1 103 0
 282 00fa FF91      		pop r31
 283 00fc EF91      		pop r30
 284 00fe BF91      		pop r27
 285 0100 AF91      		pop r26
 286 0102 9F91      		pop r25
 287 0104 8F91      		pop r24
 288 0106 7F91      		pop r23
 289 0108 6F91      		pop r22
 290               	.LVL18:
 291 010a 5F91      		pop r21
 292 010c 4F91      		pop r20
 293 010e 3F91      		pop r19
 294 0110 2F91      		pop r18
 295 0112 0F90      		pop r0
 296 0114 0FBE      		out __SREG__,r0
 297 0116 0F90      		pop r0
 298 0118 1F90      		pop r1
 299 011a 1895      		reti
 300               		.cfi_endproc
 301               	.LFE3:
 303               		.data
 306               	oldnote.1588:
 307 0000 00        		.byte	0
 308 0001 00        		.byte	0
 309 0002 64        		.byte	100
 310 0003 42        		.byte	66
 311               		.text
 312               	.Letext0:
 313               		.file 2 "d:\\avr8-gnu-toolchain\\avr\\include\\stdint.h"
 314               		.file 3 "d:\\avr8-gnu-toolchain\\avr\\include\\math.h"
DEFINED SYMBOLS
                            *ABS*:00000000 mod_mod.c
C:\Users\jtc-b\AppData\Local\Temp\ccnRmdDT.s:2      *ABS*:0000003e __SP_H__
C:\Users\jtc-b\AppData\Local\Temp\ccnRmdDT.s:3      *ABS*:0000003d __SP_L__
C:\Users\jtc-b\AppData\Local\Temp\ccnRmdDT.s:4      *ABS*:0000003f __SREG__
C:\Users\jtc-b\AppData\Local\Temp\ccnRmdDT.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\jtc-b\AppData\Local\Temp\ccnRmdDT.s:6      *ABS*:00000001 __zero_reg__
C:\Users\jtc-b\AppData\Local\Temp\ccnRmdDT.s:13     .text.startup:00000000 main
C:\Users\jtc-b\AppData\Local\Temp\ccnRmdDT.s:105    .text:00000000 __vector_21
C:\Users\jtc-b\AppData\Local\Temp\ccnRmdDT.s:306    .data:00000000 oldnote.1588

UNDEFINED SYMBOLS
__floatunsisf
__mulsf3
__addsf3
__divsf3
__subsf3
__fixunssfsi
round
pow
__do_copy_data
